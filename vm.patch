diff --git a/include/wren/config.h b/include/wren/config.h
index f5676e87d..6775bc41b 100644
--- a/include/wren/config.h
+++ b/include/wren/config.h
@@ -15,8 +15,8 @@ void wr_config_set_show_axis_aligned_bounding_boxes(bool show);
 void wr_config_set_show_shadow_axis_aligned_bounding_boxes(bool show);
 void wr_config_set_show_frustums(bool show);
 void wr_config_set_bounding_volume_program(WrShaderProgram *program);
-void wr_config_set_requires_flush_after_draw(bool require);
-void wr_config_set_requires_depth_buffer_distortion(bool require);
+// void wr_config_set_requires_flush_after_draw(bool require);
+// void wr_config_set_requires_depth_buffer_distortion(bool require);
 void wr_config_enable_point_size(bool enable);
 
 int wr_config_get_max_active_spot_light_count();
diff --git a/src/webots/gui/WbWrenWindow.cpp b/src/webots/gui/WbWrenWindow.cpp
index cde786289..b2fd44614 100644
--- a/src/webots/gui/WbWrenWindow.cpp
+++ b/src/webots/gui/WbWrenWindow.cpp
@@ -167,11 +167,11 @@ void WbWrenWindow::initialize() {
   // Workaround an OpenGL driver bug occuring in VMWare virtual machines:
   // - The OpenGL state when calling the glDrawElements function may be corrupted.
   //   In such case, the previous vertex buffers may be overriden with the current material.
-  wr_config_set_requires_flush_after_draw(WbSysInfo::isVirtualMachine());
+  // wr_config_set_requires_flush_after_draw(WbSysInfo::isVirtualMachine());
 
   // Workaround an OpenGL driver bug occuring in VMWare virtual machines:
   // - The OpenGL depth buffer returns the square root of the expected value when getting the depth buffer.
-  wr_config_set_requires_depth_buffer_distortion(WbSysInfo::isVirtualMachine());
+  // wr_config_set_requires_depth_buffer_distortion(WbSysInfo::isVirtualMachine());
 
   updateFrameBuffer();
 
@@ -445,15 +445,15 @@ void WbWrenWindow::feedMultimediaStreamer() {
 }
 
 void WbWrenWindow::readPixels(int width, int height, unsigned int format, void *buffer) {
-#ifdef __linux__
-  if (WbSysInfo::isVirtualMachine()) {
-    // Reading the front buffer is not supported by all OpenGL implementations (especially on Linux running in a VM).
-    // In that case, to read the front buffer, we need to swap the buffers, read the back buffer and swap the buffers again.
-    // However, doing this may cause flickering on platforms where reading the front buffer is supported (including macOS).
-    WbWrenOpenGlContext::instance()->swapBuffers(this);
-    wr_scene_get_main_buffer(wr_scene_get_instance(), width, height, format, GL_UNSIGNED_BYTE, GL_BACK, buffer);
-    WbWrenOpenGlContext::instance()->swapBuffers(this);
-  } else
-#endif
-    wr_scene_get_main_buffer(wr_scene_get_instance(), width, height, format, GL_UNSIGNED_BYTE, GL_FRONT, buffer);
+  //#ifdef __linux__
+  //  if (WbSysInfo::isVirtualMachine()) {
+  //    // Reading the front buffer is not supported by all OpenGL implementations (especially on Linux running in a VM).
+  //    // In that case, to read the front buffer, we need to swap the buffers, read the back buffer and swap the buffers again.
+  //    // However, doing this may cause flickering on platforms where reading the front buffer is supported (including macOS).
+  //    WbWrenOpenGlContext::instance()->swapBuffers(this);
+  //    wr_scene_get_main_buffer(wr_scene_get_instance(), width, height, format, GL_UNSIGNED_BYTE, GL_BACK, buffer);
+  //    WbWrenOpenGlContext::instance()->swapBuffers(this);
+  //  } else
+  //#endif
+  wr_scene_get_main_buffer(wr_scene_get_instance(), width, height, format, GL_UNSIGNED_BYTE, GL_FRONT, buffer);
 }
diff --git a/src/wren/Config.cpp b/src/wren/Config.cpp
index 4ecf852df..1ca9fd9a6 100644
--- a/src/wren/Config.cpp
+++ b/src/wren/Config.cpp
@@ -45,8 +45,8 @@ namespace wren {
     static StaticMesh *cSphereMesh = NULL;
     static StaticMesh *cBoxMesh = NULL;
     static ShaderProgram *cBoundingVolumeProgram = NULL;
-    static bool cRequiresFlushAfterDraw = false;
-    static bool cRequiresDepthBufferDistortion = false;
+    // static bool cRequiresFlushAfterDraw = false;
+    // static bool cRequiresDepthBufferDistortion = false;
 
     void enableShadows(bool enable) { cAreShadowsEnabled = enable; }
 
@@ -103,9 +103,9 @@ namespace wren {
 
     void setBoundingVolumeProgram(ShaderProgram *program) { cBoundingVolumeProgram = program; }
 
-    void setRequiresFlushAfterDraw(bool require) { cRequiresFlushAfterDraw = require; }
+    // void setRequiresFlushAfterDraw(bool require) { cRequiresFlushAfterDraw = require; }
 
-    void setRequiresDepthBufferDistortion(bool require) { cRequiresDepthBufferDistortion = require; }
+    // void setRequiresDepthBufferDistortion(bool require) { cRequiresDepthBufferDistortion = require; }
 
     void drawAabb(const primitive::Aabb &aabb) {
       if (!cShowAabbs && !cShowShadowAabbs)
@@ -182,9 +182,9 @@ namespace wren {
 
     bool showBoundingSpheres() { return cShowBoundingSpheres; }
 
-    bool requiresFlushAfterDraw() { return cRequiresFlushAfterDraw; }
+    // bool requiresFlushAfterDraw() { return cRequiresFlushAfterDraw; }
 
-    bool requiresDepthBufferDistortion() { return cRequiresDepthBufferDistortion; }
+    // bool requiresDepthBufferDistortion() { return cRequiresDepthBufferDistortion; }
 
     bool areShadowsEnabled() { return cAreShadowsEnabled; }
 
@@ -239,13 +239,13 @@ void wr_config_set_bounding_volume_program(WrShaderProgram *program) {
   wren::config::setBoundingVolumeProgram(reinterpret_cast<wren::ShaderProgram *>(program));
 }
 
-void wr_config_set_requires_flush_after_draw(bool require) {
-  wren::config::setRequiresFlushAfterDraw(require);
-}
+// void wr_config_set_requires_flush_after_draw(bool require) {
+//  wren::config::setRequiresFlushAfterDraw(require);
+//}
 
-void wr_config_set_requires_depth_buffer_distortion(bool require) {
-  wren::config::setRequiresDepthBufferDistortion(require);
-}
+// void wr_config_set_requires_depth_buffer_distortion(bool require) {
+//  wren::config::setRequiresDepthBufferDistortion(require);
+//}
 
 bool wr_config_are_shadows_enabled() {
   return wren::config::areShadowsEnabled();
diff --git a/src/wren/Config.hpp b/src/wren/Config.hpp
index fb3ad181c..77d7b2aee 100644
--- a/src/wren/Config.hpp
+++ b/src/wren/Config.hpp
@@ -31,16 +31,16 @@ namespace wren {
     void setShowShadowAabbs(bool show);
     void setShowBoundingSpheres(bool show);
     void setBoundingVolumeProgram(ShaderProgram *program);
-    void setRequiresFlushAfterDraw(bool require);
-    void setRequiresDepthBufferDistortion(bool require);
+    // void setRequiresFlushAfterDraw(bool require);
+    // void setRequiresDepthBufferDistortion(bool require);
     void drawBoundingSphere(const primitive::Sphere &sphere);
     void drawAabb(const primitive::Aabb &aabb);
 
     bool showAabbs();
     bool showShadowAabbs();
     bool showBoundingSpheres();
-    bool requiresFlushAfterDraw();
-    bool requiresDepthBufferDistortion();
+    // bool requiresFlushAfterDraw();
+    // bool requiresDepthBufferDistortion();
     bool areShadowsEnabled();
     bool isPointSizeEnabled();
     float lineScale();
diff --git a/src/wren/DynamicMesh.cpp b/src/wren/DynamicMesh.cpp
index fbe711618..095719d12 100644
--- a/src/wren/DynamicMesh.cpp
+++ b/src/wren/DynamicMesh.cpp
@@ -122,8 +122,8 @@ namespace wren {
   void DynamicMesh::render(unsigned int drawingMode) {
     bind();
     glDrawElements(drawingMode, mIndices.size(), GL_UNSIGNED_INT, NULL);
-    if (config::requiresFlushAfterDraw())
-      glFlush();
+    // if (config::requiresFlushAfterDraw())
+    //  glFlush();
   }
 
   void DynamicMesh::clear(bool vertices, bool normals, bool textureCoordinates, bool colors) {
diff --git a/src/wren/FrameBuffer.cpp b/src/wren/FrameBuffer.cpp
index 3429f4450..85df3feac 100644
--- a/src/wren/FrameBuffer.cpp
+++ b/src/wren/FrameBuffer.cpp
@@ -210,10 +210,10 @@ namespace wren {
 #else
     glReadPixels(x, (flipY ? mHeight - 1 - y : y), 1, 1, GL_DEPTH_COMPONENT, GL_FLOAT, data);
 #endif
-    if (config::requiresDepthBufferDistortion()) {
-      GLfloat *fData = static_cast<GLfloat *>(data);
-      fData[0] = fData[0] * fData[0];
-    }
+    // if (config::requiresDepthBufferDistortion()) {
+    //  GLfloat *fData = static_cast<GLfloat *>(data);
+    //  fData[0] = fData[0] * fData[0];
+    //}
     glstate::bindReadFrameBuffer(currentReadFrameBuffer);
   }
 
diff --git a/src/wren/ShadowVolumeCaster.cpp b/src/wren/ShadowVolumeCaster.cpp
index db0d8a052..61749eb54 100644
--- a/src/wren/ShadowVolumeCaster.cpp
+++ b/src/wren/ShadowVolumeCaster.cpp
@@ -379,8 +379,8 @@ namespace wren {
 
     glstate::bindElementArrayBuffer(shadowVolume.mGlNameSidesIndexBuffer);
     glDrawElements(GL_TRIANGLES, shadowVolume.mIndexCountSides, GL_UNSIGNED_INT, reinterpret_cast<void *>(0));
-    if (config::requiresFlushAfterDraw())
-      glFlush();
+    // if (config::requiresFlushAfterDraw())
+    //  glFlush();
     glstate::releaseElementArrayBuffer(shadowVolume.mGlNameSidesIndexBuffer);
   }
 
@@ -398,8 +398,8 @@ namespace wren {
     // avoid z-fighting between actual geometry and light cap (shouldn't be necessary?)
     glstate::setPolygonOffset(true, 0.1f, 5.0f);
     glDrawElements(GL_TRIANGLES, shadowVolume.mIndexCountCaps, GL_UNSIGNED_INT, reinterpret_cast<void *>(0));
-    if (config::requiresFlushAfterDraw())
-      glFlush();
+    // if (config::requiresFlushAfterDraw())
+    //  glFlush();
     glstate::setPolygonOffset(false, 0.1f, 5.0f);
 
     glstate::releaseElementArrayBuffer(shadowVolume.mGlNameCapsIndexBuffer);
diff --git a/src/wren/StaticMesh.cpp b/src/wren/StaticMesh.cpp
index 346dffe47..1889687de 100644
--- a/src/wren/StaticMesh.cpp
+++ b/src/wren/StaticMesh.cpp
@@ -1702,8 +1702,8 @@ namespace wren {
     bind();
 
     glDrawElements(drawingMode, mCacheData->mIndexCount, GL_UNSIGNED_INT, NULL);
-    if (config::requiresFlushAfterDraw())
-      glFlush();
+    // if (config::requiresFlushAfterDraw())
+    //  glFlush();
   }
 
   size_t StaticMesh::sortingId() const { return static_cast<size_t>(mCacheData->id()); }
